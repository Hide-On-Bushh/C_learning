#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//int main()
//{
//	//int a = 5 / 2;//商2余1
//	double  a= 5 / 2.0;
//	printf("a=%lf\n", a);
//	return 0;
 
//int main()
////>> --右移操作符 移动的是二进制
//{
//	//int a = 16;//00000000000000000000000000010000    32位
//	//int b = a >> 2;
//	//printf("%d", b);
//	int a = -1;
//	int b = a >> 1;
//	printf("%d", b);
//	return 0;
//	//正数二进制有：有原码、补码、反码
//	//存储到内存都是补码
//	//10000000000000000000000000000001 - 原码
//	//11111111111111111111111111111110 - 反码
//	//11111111111111111111111111111111 - 补码
//	//算术右移一位补的还是符号位，全1，所以打印的结果还是原码-1
//}

//int main()
//{
//	int a = 5;
//	int b = a << 1;//左移直接补0
//	printf("%d", b);
//	return 0;
// }

//int main()
//{
//	//& - 按2进制位与
//	int a = 3;
//	int b = 5;
//	int c = a & b;
//	//000000000000000000000011  3
//	//000000000000000000000101  5
//	//000000000000000000000001  a&b
//	printf("%d", c);
//	return 0;
//}

//int main()
//{
//	//int a = 3;//按位或
//	//	int b = 5;
//	//	int c = a | b;
//	//000000000000000000000011  3
//	//000000000000000000000101  5
//	//000000000000000000000111  a&b
//	/*printf("%d",c);*/
//	return 0;
//}

//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a ^ b;//按2进制异或   相同为0 相异为1
////	//000000000000000000000011  3
//	//000000000000000000000101  5
//	//000000000000000000000110  a^b
//	printf("%d", c);
//	return 0;
//}

//ab的值互换不可以使用第三个变量

//加减法
//int main()
//{
//	int a = 5;
//	int b = 3;
//	a = a + b;//8
//	b = a - b;//原来a的值等于b
//	a = a - b;//a=8的值减去b=3（原来a的值）的值
//
//}

//异或法 原理类似加减法
//int main()
//{
//	int a = 5;
//	int b = 3;
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//	return 0;
//}

//计算整数在内存中二进制的1的个数(相当于统计补码几个1)
//int main()
//{
//	int num = 0;
//	int count = 0;
//	scanf("%d", &num);
//	while (num)//num非0时循环语句
//	{
//		if (1 == num % 2)
//			count++;
//		num = num >>1;//相当于除2
//	}
//	printf("%d", count);
//	return 0;
//}//但是这样的算法如果是负数会存在问题，每次结果为0

//int main()
//{
//	int num = 0;
//	int count = 0;
//	scanf("%d", &num);
//	int i = 0;
//	for (i = 0; i < 32; i++)
//	{
//		if (1 == ((num >> i) & 1))//让num与00000000000000000000000001按位与，每次右移i位结果为1说明num最后一位为1
//			count++;
//	}
//	printf("%d", count);
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	int* p = &a;//取地址操作符
//	*p = 20;//解引用操作符
//	//a = a + 2;
//	//a += 2;//复合赋值符
//
//	//a = a & 1;
//	//a &= 1;
//
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	char c = 'c';
//	char* p = &c;
//	int arr[10] = { 0,1,2 };
//	printf("%d\n",sizeof(a));//4
//	printf("%d\n",sizeof(c));//1
//	printf("%d\n",sizeof(p));//4  32位 指针大小要么4要么8
//	printf("%d\n",sizeof(arr));//40
//	return 0;
//}

//int main()
//{
//	short s = 0;
//	int a = 10;
//	printf("%d", sizeof(s = a + 5));//s一直都是短整型 2
//	printf("%d", s);//s=0  sizeof里放的表达式不会真的参与计算
//	return 0;
//}

//int main()
//{
//	int a = 0;
//	//~按（2进制位）取反
//	//000000000000000000000000000 - a的2进制表示 0的二进制位相同
//	//111111111111111111111111111 - 补码 （所有位取反后的结果）   补码-1后取反得到原码   原码取反+1求得补码
//	//111111111111111111111111110 - 反码
//	//100000000000000000000000001 - 原码 %d打印的是原码，所以补码要求到它的原码
//	printf("%d", ~a);
//	return 0;
//}

//int main()
//{
//	int a = 11;//1011
//	a = a | (1 << 2);
//	printf("%d\n", a);
//	//1011
//	//0001   1<<2  0100
//	a = a & (~(1 << 2));
//	//1111 a
//	//0001 1<<2 再取反变成 1011与a=1111按位与
//	printf("%d\n", a);
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	/*printf("%d\n", ++a);*///前置++，先++再使用
//	printf("%d\n",a++);//后置++，先使用，再++
//	printf("%d\n",a);
//	return 0;
//}

//void tese1(int arr[])
//{
//printf("%d\n", sizeof(arr));//传参穿的是数组第一个元素地址，是指针接收，4个字节
//}
//
//void tese2(char ch[])
//{
//	printf("%d\n", sizeof(ch));//同理
//}
//int main()
//	{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("%d\n", sizeof(arr));//整型元素 10个 4*10
//	printf("%d\n", sizeof(ch));//字符型 10*1
//	test1(arr);
//	test2(ch);
//	return 0;
//	}

//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++;//a++是后使用，所以在式子里值为0,只要左边的数为0&&任何数都为0（有0不会再计算任何数），所以后面的++b d++都没有计算，a用了自增所以为1
//	printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);结果为1234
//	return 0;
//}

//int main()
//{
//	int i = 0, a = 1, b = 2, c = 3, d = 4;
//	i = a++ || ++b || d++;//a++是后使用，但a的值为1与后面任何数||都为1，所以后面的++b d++都没有计算
//	printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);//结果为2234
//	return 0;
//}

//int get_max(int x, int y)
//{
//	return x > y ? x : y;
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	//调用函数的时候（）就是调用操作符
//	int max = get_max(a, b);
//	printf("%d\n", max);
//	return 0;
//}

//创建了一个结构体类型 struct Stu
//struct Stu
//{
//	//成员变量
//	char name[20];
//	int age;
//	char id[20];
//};

//int main()
//{
//	int a = 10;
//	//使用struct Stu这个类型创建一个学生对象s1,并初始化
//	struct Stu s1 = { "张三",20,"2019100545" };
//	printf("%s\n", s1.name);
//	printf("%d\n", s1.age);
//	printf("%s\n", s1.id);
//	//结构体.变量名
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	//使用struct Stu这个类型创建一个学生对象s1,并初始化
//	struct Stu s1 = { "张三",20,"2019100545" };
//	struct Stu* ps = &s1;
//	printf("%s\n", ps->name);//(*ps).name
//	printf("%d\n", ps->age);
//	printf("%s\n", ps->id);
//	//结构体指针->变量名
//	//结构体变量名
//	return 0;
//}

//整型提升
//int main()
//{
//	char a = 3;
//	//00000011 char类型占一个字节，8比特位，原本是32位
//	char b = 127;
//	//01111111
//	char c = a + b;
//	//a+b=10000010 因为c 的最高位是 1 所以在最高位前面补 1 即可，补够32位，提升后补码为：11111111 11111111 11111111 10000010
//	//反码：11111111 11111111 11111111 10000001
//	//原码：10000000 00000000 00000000 01111110符号位不变
//	//-126
//	printf("%d\n", c);//进行打印时是以 %d 的形式即整数 int 的类型，打印的是原码
//}

//整型提升实例1
//int main()
//{
//	char a = 0xb6;//10110110
//	short b = 0xb600;//1011011000
//	int c = 0xb60000;
//	if (a == 0xb6)
//		printf("a");//因为==也算运算，所以a要发生整形提升，补1，a的值发生变化
//	if (b == 0xb600)
//		printf("b");//同理
//	if (c == 0xb600000);//c本身就是整形，不用发生整型提升，所以最后只会打印c
//	printf("c");
//	return 0;
//}

//练习

//#include <stdio.h>
//int main()
//{
//	int a, b, c;
//	a = 5;
//	c = ++a;//  c=6 a=6
//	b = ++c, c++, ++a, a++;// 逗号表达式从左向右依次计算 c=8 a=8 b=7
//	b += a++ + c;//a=9 b=23 c=8 加减结束后a才自增
//	printf("a=%d b=%d c=%d", a, b, c);
//	return 0;
//}

//int main()
//{
//	unsigned char a = 200;//1100 1000 a只存了8个bit位，实际上有32位
//	unsigned char b = 100;//0110 0100
//	unsigned char c = 0;
//	c = a + b;//整型提升 因为是无符号 ab高位直接不0补到32位  如果是char类型高位补符号位
//
//	//a - 00000000 000000000 1100 1000
//	//b - 00000000 000000000 0110 0100
//	// 
//	//a+b - 00000000 000000001 0010 1100正数原反补码相同为300
//	// 
//	//若果一定要放到c里面去只能存8个bit位最后c=0010 1100 同理44
//	printf("%d %d", a + b, c);//打印原码300,44
//	return 0;
//}